#!/bin/bash

export GIT_USER_ID=danicc097
export GIT_REPO_ID=openapi-go-gin-postgres-sqlc

SPEC="openapi.yaml"
GEN_OUT_DIR="."
PWD="$(pwd)"

x.openapi() {
  docker run --rm \
    -v "${PWD}/internal:/local" \
    -e GO_POST_PROCESS_FILE="/usr/bin/env gofmt -w" \
    -e "GIT_USER_ID=$GIT_USER_ID" \
    -e "GIT_REPO_ID=$GIT_REPO_ID" \
    openapitools/openapi-generator-cli "$@"
}

x.validate() {
  x.openapi validate -i "/local/$SPEC"
}

x.generate() {
  # TODO should generate everything in separate folder, then diff what we want:
  # models should be overriden, at least until seeing the best way to diff against sqlc generated ones
  # api_* should all be ignored -> we get compilation errors if we dont implement a new route or the name has changed.

  x.openapi generate -g go-gin-server -i "/local/$SPEC" -o "/local/$GEN_OUT_DIR" --additional-properties=packageName=openapi,apiPath=gen
  local name="$(id -un)"
  sudo chown -R "$name:$name" "internal/$GEN_OUT_DIR"
  cp internal/static/swagger-override/swagger-initializer.js internal/static/swagger-ui/
  cp internal/"$SPEC" "$PWD"/internal/static/swagger-ui
}

x.build() {
  x.generate
  go build -o openapi-go-gin-postgres-sqlc "$PWD"/cmd/rest-server/main.go
}

x.run() {
  x.build
  ./openapi-go-gin-postgres-sqlc
}

x.download_swagger_ui() {
  name="$(curl --silent "https://api.github.com/repos/swagger-api/swagger-ui/releases/latest" | jq -r ".. .tag_name? // empty")"
  curl -fsSL "github.com/swagger-api/swagger-ui/archive/refs/tags/$name.tar.gz" -o swagger-ui.tar.gz
  tar xf swagger-ui.tar.gz swagger-ui-"${name#*v}"/dist --one-top-level=swagger-ui --strip-components=2
  rm swagger-ui.tar.gz
  mkdir -p internal/static/swagger-ui
  mv swagger-ui/* internal/static/swagger-ui/
  rm -r swagger-ui
}
# --------------------- completion and delegation --------------------
#      `complete -C foo foo` > `source <(foo bloated_completion)`

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=("${line##declare -f x.}")
done < <(declare -F)
mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
  done
  exit
fi

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "x.$EXE" "$@"
    exit $?
  fi
done

if [[ -n "$1" ]]; then
  declare CMD="$1"
  shift
  for c in "${COMMANDS[@]}"; do
    declare cmd=$(command -v "x.$c")
    if [[ $c == "$CMD" && -n "$cmd" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi
