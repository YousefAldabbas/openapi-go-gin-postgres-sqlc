/**
 * Generated by orval v6.10.3 üç∫
 * Do not edit manually.
 * OpenAPI openapi-go-gin-postgres-sqlc
 * openapi-go-gin-postgres-sqlc
 * OpenAPI spec version: 2.0.0
 */
import axios from 'axios'
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios'
import { useQuery, useInfiniteQuery } from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseInfiniteQueryOptions,
  QueryFunction,
  UseQueryResult,
  UseInfiniteQueryResult,
  QueryKey,
} from '@tanstack/react-query'
import type { HTTPValidationError } from '.././model'

export const myProviderCallback = (options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.get(`/auth/myprovider/callback`, options)
}

export const getMyProviderCallbackQueryKey = () => [`/auth/myprovider/callback`]

export type MyProviderCallbackInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof myProviderCallback>>>
export type MyProviderCallbackInfiniteQueryError = AxiosError<unknown>

export const useMyProviderCallbackInfinite = <
  TData = Awaited<ReturnType<typeof myProviderCallback>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof myProviderCallback>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMyProviderCallbackQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof myProviderCallback>>> = ({ signal }) =>
    myProviderCallback({ signal, ...axiosOptions })

  const query = useInfiniteQuery<Awaited<ReturnType<typeof myProviderCallback>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

export type MyProviderCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof myProviderCallback>>>
export type MyProviderCallbackQueryError = AxiosError<unknown>

export const useMyProviderCallback = <
  TData = Awaited<ReturnType<typeof myProviderCallback>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof myProviderCallback>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMyProviderCallbackQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof myProviderCallback>>> = ({ signal }) =>
    myProviderCallback({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof myProviderCallback>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

export const myProviderLogin = (options?: AxiosRequestConfig): Promise<AxiosResponse<unknown>> => {
  return axios.get(`/auth/myprovider/login`, options)
}

export const getMyProviderLoginQueryKey = () => [`/auth/myprovider/login`]

export type MyProviderLoginInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof myProviderLogin>>>
export type MyProviderLoginInfiniteQueryError = AxiosError<void>

export const useMyProviderLoginInfinite = <
  TData = Awaited<ReturnType<typeof myProviderLogin>>,
  TError = AxiosError<void>,
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof myProviderLogin>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMyProviderLoginQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof myProviderLogin>>> = ({ signal }) =>
    myProviderLogin({ signal, ...axiosOptions })

  const query = useInfiniteQuery<Awaited<ReturnType<typeof myProviderLogin>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

export type MyProviderLoginQueryResult = NonNullable<Awaited<ReturnType<typeof myProviderLogin>>>
export type MyProviderLoginQueryError = AxiosError<void>

export const useMyProviderLogin = <
  TData = Awaited<ReturnType<typeof myProviderLogin>>,
  TError = AxiosError<void>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof myProviderLogin>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMyProviderLoginQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof myProviderLogin>>> = ({ signal }) =>
    myProviderLogin({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof myProviderLogin>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

export const events = (options?: AxiosRequestConfig): Promise<AxiosResponse<string>> => {
  return axios.get(`/events`, options)
}

export const getEventsQueryKey = () => [`/events`]

export type EventsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof events>>>
export type EventsInfiniteQueryError = AxiosError<unknown>

export const useEventsInfinite = <TData = Awaited<ReturnType<typeof events>>, TError = AxiosError<unknown>>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof events>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getEventsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof events>>> = ({ signal }) => events({ signal, ...axiosOptions })

  const query = useInfiniteQuery<Awaited<ReturnType<typeof events>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

export type EventsQueryResult = NonNullable<Awaited<ReturnType<typeof events>>>
export type EventsQueryError = AxiosError<unknown>

export const useEvents = <TData = Awaited<ReturnType<typeof events>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof events>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getEventsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof events>>> = ({ signal }) => events({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof events>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Ping pongs
 */
export const ping = (options?: AxiosRequestConfig): Promise<AxiosResponse<string>> => {
  return axios.get(`/ping`, options)
}

export const getPingQueryKey = () => [`/ping`]

export type PingInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof ping>>>
export type PingInfiniteQueryError = AxiosError<HTTPValidationError>

export const usePingInfinite = <
  TData = Awaited<ReturnType<typeof ping>>,
  TError = AxiosError<HTTPValidationError>,
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getPingQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof ping>>> = ({ signal }) => ping({ signal, ...axiosOptions })

  const query = useInfiniteQuery<Awaited<ReturnType<typeof ping>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

export type PingQueryResult = NonNullable<Awaited<ReturnType<typeof ping>>>
export type PingQueryError = AxiosError<HTTPValidationError>

export const usePing = <TData = Awaited<ReturnType<typeof ping>>, TError = AxiosError<HTTPValidationError>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof ping>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getPingQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof ping>>> = ({ signal }) => ping({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof ping>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Returns this very OpenAPI spec.
 */
export const openapiYamlGet = (options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> => {
  return axios.get(`/openapi.yaml`, {
    responseType: 'blob',
    ...options,
  })
}

export const getOpenapiYamlGetQueryKey = () => [`/openapi.yaml`]

export type OpenapiYamlGetInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof openapiYamlGet>>>
export type OpenapiYamlGetInfiniteQueryError = AxiosError<unknown>

export const useOpenapiYamlGetInfinite = <
  TData = Awaited<ReturnType<typeof openapiYamlGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof openapiYamlGet>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOpenapiYamlGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof openapiYamlGet>>> = ({ signal }) =>
    openapiYamlGet({ signal, ...axiosOptions })

  const query = useInfiniteQuery<Awaited<ReturnType<typeof openapiYamlGet>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

export type OpenapiYamlGetQueryResult = NonNullable<Awaited<ReturnType<typeof openapiYamlGet>>>
export type OpenapiYamlGetQueryError = AxiosError<unknown>

export const useOpenapiYamlGet = <
  TData = Awaited<ReturnType<typeof openapiYamlGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof openapiYamlGet>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOpenapiYamlGetQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof openapiYamlGet>>> = ({ signal }) =>
    openapiYamlGet({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof openapiYamlGet>>, TError, TData>(queryKey, queryFn, {
    staleTime: 3600000,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}
