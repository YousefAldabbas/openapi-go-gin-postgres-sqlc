// Code generated by counterfeiter. DO NOT EDIT.
package repostesting

import (
	"context"
	"sync"

	"github.com/danicc097/openapi-go-gin-postgres-sqlc/internal/models"
	"github.com/danicc097/openapi-go-gin-postgres-sqlc/internal/repos"
	"github.com/danicc097/openapi-go-gin-postgres-sqlc/internal/repos/postgresql/gen/db"
)

type FakeProject struct {
	ProjectByIDStub        func(context.Context, db.DBTX, int) (*db.Project, error)
	projectByIDMutex       sync.RWMutex
	projectByIDArgsForCall []struct {
		arg1 context.Context
		arg2 db.DBTX
		arg3 int
	}
	projectByIDReturns struct {
		result1 *db.Project
		result2 error
	}
	projectByIDReturnsOnCall map[int]struct {
		result1 *db.Project
		result2 error
	}
	ProjectByNameStub        func(context.Context, db.DBTX, models.Project) (*db.Project, error)
	projectByNameMutex       sync.RWMutex
	projectByNameArgsForCall []struct {
		arg1 context.Context
		arg2 db.DBTX
		arg3 models.Project
	}
	projectByNameReturns struct {
		result1 *db.Project
		result2 error
	}
	projectByNameReturnsOnCall map[int]struct {
		result1 *db.Project
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeProject) ProjectByID(arg1 context.Context, arg2 db.DBTX, arg3 int) (*db.Project, error) {
	fake.projectByIDMutex.Lock()
	ret, specificReturn := fake.projectByIDReturnsOnCall[len(fake.projectByIDArgsForCall)]
	fake.projectByIDArgsForCall = append(fake.projectByIDArgsForCall, struct {
		arg1 context.Context
		arg2 db.DBTX
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ProjectByIDStub
	fakeReturns := fake.projectByIDReturns
	fake.recordInvocation("ProjectByID", []interface{}{arg1, arg2, arg3})
	fake.projectByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeProject) ProjectByIDCallCount() int {
	fake.projectByIDMutex.RLock()
	defer fake.projectByIDMutex.RUnlock()
	return len(fake.projectByIDArgsForCall)
}

func (fake *FakeProject) ProjectByIDCalls(stub func(context.Context, db.DBTX, int) (*db.Project, error)) {
	fake.projectByIDMutex.Lock()
	defer fake.projectByIDMutex.Unlock()
	fake.ProjectByIDStub = stub
}

func (fake *FakeProject) ProjectByIDArgsForCall(i int) (context.Context, db.DBTX, int) {
	fake.projectByIDMutex.RLock()
	defer fake.projectByIDMutex.RUnlock()
	argsForCall := fake.projectByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeProject) ProjectByIDReturns(result1 *db.Project, result2 error) {
	fake.projectByIDMutex.Lock()
	defer fake.projectByIDMutex.Unlock()
	fake.ProjectByIDStub = nil
	fake.projectByIDReturns = struct {
		result1 *db.Project
		result2 error
	}{result1, result2}
}

func (fake *FakeProject) ProjectByIDReturnsOnCall(i int, result1 *db.Project, result2 error) {
	fake.projectByIDMutex.Lock()
	defer fake.projectByIDMutex.Unlock()
	fake.ProjectByIDStub = nil
	if fake.projectByIDReturnsOnCall == nil {
		fake.projectByIDReturnsOnCall = make(map[int]struct {
			result1 *db.Project
			result2 error
		})
	}
	fake.projectByIDReturnsOnCall[i] = struct {
		result1 *db.Project
		result2 error
	}{result1, result2}
}

func (fake *FakeProject) ProjectByName(arg1 context.Context, arg2 db.DBTX, arg3 models.Project) (*db.Project, error) {
	fake.projectByNameMutex.Lock()
	ret, specificReturn := fake.projectByNameReturnsOnCall[len(fake.projectByNameArgsForCall)]
	fake.projectByNameArgsForCall = append(fake.projectByNameArgsForCall, struct {
		arg1 context.Context
		arg2 db.DBTX
		arg3 models.Project
	}{arg1, arg2, arg3})
	stub := fake.ProjectByNameStub
	fakeReturns := fake.projectByNameReturns
	fake.recordInvocation("ProjectByName", []interface{}{arg1, arg2, arg3})
	fake.projectByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeProject) ProjectByNameCallCount() int {
	fake.projectByNameMutex.RLock()
	defer fake.projectByNameMutex.RUnlock()
	return len(fake.projectByNameArgsForCall)
}

func (fake *FakeProject) ProjectByNameCalls(stub func(context.Context, db.DBTX, models.Project) (*db.Project, error)) {
	fake.projectByNameMutex.Lock()
	defer fake.projectByNameMutex.Unlock()
	fake.ProjectByNameStub = stub
}

func (fake *FakeProject) ProjectByNameArgsForCall(i int) (context.Context, db.DBTX, models.Project) {
	fake.projectByNameMutex.RLock()
	defer fake.projectByNameMutex.RUnlock()
	argsForCall := fake.projectByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeProject) ProjectByNameReturns(result1 *db.Project, result2 error) {
	fake.projectByNameMutex.Lock()
	defer fake.projectByNameMutex.Unlock()
	fake.ProjectByNameStub = nil
	fake.projectByNameReturns = struct {
		result1 *db.Project
		result2 error
	}{result1, result2}
}

func (fake *FakeProject) ProjectByNameReturnsOnCall(i int, result1 *db.Project, result2 error) {
	fake.projectByNameMutex.Lock()
	defer fake.projectByNameMutex.Unlock()
	fake.ProjectByNameStub = nil
	if fake.projectByNameReturnsOnCall == nil {
		fake.projectByNameReturnsOnCall = make(map[int]struct {
			result1 *db.Project
			result2 error
		})
	}
	fake.projectByNameReturnsOnCall[i] = struct {
		result1 *db.Project
		result2 error
	}{result1, result2}
}

func (fake *FakeProject) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.projectByIDMutex.RLock()
	defer fake.projectByIDMutex.RUnlock()
	fake.projectByNameMutex.RLock()
	defer fake.projectByNameMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeProject) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repos.Project = new(FakeProject)
