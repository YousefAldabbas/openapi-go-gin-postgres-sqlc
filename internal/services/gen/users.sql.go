// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: users.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const GetRoles = `-- name: GetRoles :many
select
  ENUM_RANGE(null::users.role)::text[]
`

func (q *Queries) GetRoles(ctx context.Context) ([][]string, error) {
	rows, err := q.db.Query(ctx, GetRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := [][]string{}
	for rows.Next() {
		var column_1 []string
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUser = `-- name: GetUser :one
select
  username,
  email,
  role,
  is_verified,
  is_active,
  is_superuser,
  created_at,
  updated_at,
  COALESCE(
    case when $1::boolean then
      (user_id)
    end, -1)::int as user_id,
  case when $1::boolean then
    (salt)
  end as salt,
  case when $1::boolean then
    (password)
  end as password
from
  users
where (email = LOWER($2)::text
  or $2::text is null)
and (username = $3::text
  or $3::text is null)
and (user_id = $4::int
  or $4::int is null)
limit 1
`

type GetUserParams struct {
	GetDbData bool
	Email     sql.NullString
	Username  sql.NullString
	UserID    sql.NullInt32
}

type GetUserRow struct {
	Username    string
	Email       string
	Role        Role
	IsVerified  bool
	IsActive    bool
	IsSuperuser bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
	UserID      int32
	Salt        interface{}
	Password    interface{}
}

func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, GetUser,
		arg.GetDbData,
		arg.Email,
		arg.Username,
		arg.UserID,
	)
	var i GetUserRow
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.IsActive,
		&i.IsSuperuser,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Salt,
		&i.Password,
	)
	return i, err
}

const ListAllUsers = `-- name: ListAllUsers :many
select
  user_id,
  username,
  email,
  role,
  is_verified,
  salt,
  password,
  is_active,
  is_superuser,
  created_at,
  updated_at
from
  users
where
  is_verified = $1::boolean
  or $1::boolean is null
`

type ListAllUsersRow struct {
	UserID      int32
	Username    string
	Email       string
	Role        Role
	IsVerified  bool
	Salt        string
	Password    string
	IsActive    bool
	IsSuperuser bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) ListAllUsers(ctx context.Context, isVerified sql.NullBool) ([]ListAllUsersRow, error) {
	rows, err := q.db.Query(ctx, ListAllUsers, isVerified)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllUsersRow{}
	for rows.Next() {
		var i ListAllUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.Role,
			&i.IsVerified,
			&i.Salt,
			&i.Password,
			&i.IsActive,
			&i.IsSuperuser,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RegisterNewUser = `-- name: RegisterNewUser :one
insert into users (username, email, password, salt, is_superuser, is_verified)
  values ($1, $2, $3, $4, $5, $6)
returning
  user_id, username, email, role, is_verified, is_active, is_superuser,
    created_at, updated_at
`

type RegisterNewUserParams struct {
	Username    string
	Email       string
	Password    string
	Salt        string
	IsSuperuser bool
	IsVerified  bool
}

type RegisterNewUserRow struct {
	UserID      int32
	Username    string
	Email       string
	Role        Role
	IsVerified  bool
	IsActive    bool
	IsSuperuser bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) RegisterNewUser(ctx context.Context, arg RegisterNewUserParams) (RegisterNewUserRow, error) {
	row := q.db.QueryRow(ctx, RegisterNewUser,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Salt,
		arg.IsSuperuser,
		arg.IsVerified,
	)
	var i RegisterNewUserRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.IsActive,
		&i.IsSuperuser,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ResetUserPassword = `-- name: ResetUserPassword :exec
update
  users
set
  password = $1,
  salt     = $2
where
  email = LOWER($3)
`

type ResetUserPasswordParams struct {
	Password string
	Salt     string
	Email    string
}

func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) error {
	_, err := q.db.Exec(ctx, ResetUserPassword, arg.Password, arg.Salt, arg.Email)
	return err
}

const UpdateUserById = `-- name: UpdateUserById :one
update
  users
set
  password = COALESCE($1, password),
  salt     = COALESCE($2, salt),
  username = COALESCE($3, username),
  email    = COALESCE(LOWER($4), email)
where
  user_id = $5
returning
  user_id,
  username,
  email,
  role,
  is_verified,
  salt,
  password,
  is_active,
  is_superuser,
  created_at,
  updated_at
`

type UpdateUserByIdParams struct {
	Password sql.NullString
	Salt     sql.NullString
	Username sql.NullString
	Email    sql.NullString
	UserID   int32
}

type UpdateUserByIdRow struct {
	UserID      int32
	Username    string
	Email       string
	Role        Role
	IsVerified  bool
	Salt        string
	Password    string
	IsActive    bool
	IsSuperuser bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) UpdateUserById(ctx context.Context, arg UpdateUserByIdParams) (UpdateUserByIdRow, error) {
	row := q.db.QueryRow(ctx, UpdateUserById,
		arg.Password,
		arg.Salt,
		arg.Username,
		arg.Email,
		arg.UserID,
	)
	var i UpdateUserByIdRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.IsVerified,
		&i.Salt,
		&i.Password,
		&i.IsActive,
		&i.IsSuperuser,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateUserRole = `-- name: UpdateUserRole :exec
update
  users
set
  role = $1
where
  user_id = $2
`

type UpdateUserRoleParams struct {
	Role   Role
	UserID int32
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, UpdateUserRole, arg.Role, arg.UserID)
	return err
}

const VerifyUserByEmail = `-- name: VerifyUserByEmail :one
update
  users
set
  is_verified = 'true'
where
  email = LOWER($1)
returning
  email
`

func (q *Queries) VerifyUserByEmail(ctx context.Context, userEmail string) (string, error) {
	row := q.db.QueryRow(ctx, VerifyUserByEmail, userEmail)
	var email string
	err := row.Scan(&email)
	return email, err
}
